<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Artifacts Reference on API Mocking and Testing | Microcks.io</title><link>https://microcks.io/documentation/references/artifacts/</link><description>Recent content in Artifacts Reference on API Mocking and Testing | Microcks.io</description><generator>Hugo</generator><language>en-US</language><lastBuildDate>Mon, 04 Nov 2024 00:00:00 +0100</lastBuildDate><atom:link href="https://microcks.io/documentation/references/artifacts/index.xml" rel="self" type="application/rss+xml"/><item><title>OpenAPI Conventions</title><link>https://microcks.io/documentation/references/artifacts/openapi-conventions/</link><pubDate>Mon, 27 May 2024 00:00:00 +0200</pubDate><guid>https://microcks.io/documentation/references/artifacts/openapi-conventions/</guid><description>Conventions In addition of schema information, Microcks uses OpenAPI Example Objects to produce working mocks and build test suite for validating your implementation.
As example fragments are actually distributed along the OpenAPI specification, Microcks collects fragments and try to associate them by name. Microcks only takes care of comprehensive request/response examples - which means that if you provide examples for input elements (parameter, requestBody) but not for output (response), incomplete examples will be discarded.</description></item><item><title>AsyncAPI Conventions</title><link>https://microcks.io/documentation/references/artifacts/asyncapi-conventions/</link><pubDate>Mon, 27 May 2024 00:00:00 +0200</pubDate><guid>https://microcks.io/documentation/references/artifacts/asyncapi-conventions/</guid><description>Conventions In addition of schema information, Microcks uses AsyncAPI Message Example Objects to produce example messages for mocking purpose.
For AsyncAPI 2.x document, the name attribute of example is mandatory so that Microcks reuses this name to identify available mock messages. Starting with AsyncAPI 3.0, the name is no longer mandatory and Microcks can then compute a name for you based on the message name and the index of example in the list.</description></item><item><title>Swagger Conventions</title><link>https://microcks.io/documentation/references/artifacts/swagger-conventions/</link><pubDate>Mon, 27 May 2024 00:00:00 +0200</pubDate><guid>https://microcks.io/documentation/references/artifacts/swagger-conventions/</guid><description>Microcks is supporting Swagger mocking and testing thanks to multi-artifacts support feature. In order to use Swagger in Microcks, you will need 2 artifacts for each API definition:
A Swagger definition that holds the API metadata and operations definitions, A Postman Collection file that holds the mock examples (requests and responses) for the different operations of the API. Conventions In order to be correctly imported and understood by Microcks, your Postman file should follow a little set of reasonable conventions and best practices.</description></item><item><title>GraphQL Conventions</title><link>https://microcks.io/documentation/references/artifacts/graphql-conventions/</link><pubDate>Mon, 27 May 2024 00:00:00 +0200</pubDate><guid>https://microcks.io/documentation/references/artifacts/graphql-conventions/</guid><description>In order to use GraphQL in Microcks, you will need two artifacts for each API definition as explained in Multi-artifacts support:
A GraphQL IDL Schema definition that holds the API metadata and operations definitions, A Postman Collection file that holds the mock examples (requests and responses) for the different operations of the GraphQL API. Conventions In order to be correctly imported and understood by Microcks, your GraphQL IDL and Postman files should follow a little set of reasonable conventions and best practices.</description></item><item><title>gRPC Conventions</title><link>https://microcks.io/documentation/references/artifacts/grpc-conventions/</link><pubDate>Mon, 27 May 2024 00:00:00 +0200</pubDate><guid>https://microcks.io/documentation/references/artifacts/grpc-conventions/</guid><description>In order to use gRPC in Microcks, you will need two artifacts for each service definition as explained in Multi-artifacts support:
A gRPC / Protocol Buffers file definition that holds the Service metadata and operations definitions, A Postman Collection file that holds the mock examples (requests and responses) for the different operations of the gRPC Service. Conventions In order to be correctly imported and understood by Microcks, your gRPC and Postman files should follow a little set of reasonable conventions and best practices.</description></item><item><title>Postman Conventions</title><link>https://microcks.io/documentation/references/artifacts/postman-conventions/</link><pubDate>Mon, 27 May 2024 00:00:00 +0200</pubDate><guid>https://microcks.io/documentation/references/artifacts/postman-conventions/</guid><description>Conventions In order to be correctly imported and understood by Microcks, your Postman Collection should follow a little set of reasonable conventions and best practices.
Your Postman collection may contain one or more API definitions. However, because it&amp;rsquo;s a best practice to consider each API as an autonomous and isolated software asset, we&amp;rsquo;d recommend managing only one API definition per Postman collection and not mixing requests related to different APIs within the same Collection, Your Postman collection description should hold a custom property named version that allows tracking of API version.</description></item><item><title>SoapUI Conventions</title><link>https://microcks.io/documentation/references/artifacts/soapui-conventions/</link><pubDate>Mon, 27 May 2024 00:00:00 +0200</pubDate><guid>https://microcks.io/documentation/references/artifacts/soapui-conventions/</guid><description>Conventions In order to be correctly imported and understood by Microcks, your SoapUI project should follow a little set of reasonable conventions and best practices.
Your SoapUI project may contain one or more Service definitions. However, because it&amp;rsquo;s a best practice to consider each Service or API as an autonomous and isolated software asset, we&amp;rsquo;d recommend managing only one Service definition per SoapUI project, Your SoapUI Mock Service should define a custom property named version that allows tracking of Service(s) version.</description></item><item><title>Http Archive Conventions</title><link>https://microcks.io/documentation/references/artifacts/har-conventions/</link><pubDate>Mon, 27 May 2024 00:00:00 +0200</pubDate><guid>https://microcks.io/documentation/references/artifacts/har-conventions/</guid><description>Conventions In order to be correctly imported and understood by Microcks, your HAR file should follow a little set of reasonable conventions and best practices.
HAR file doesn&amp;rsquo;t have the notion of API name or version. In Microcks, this notion is critical and we thus we will need to have a specific comment notation to get this information. You&amp;rsquo;ll need to add a comment line starting with microcksId: in your file and then referring the &amp;lt;API name&amp;gt;:&amp;lt;API version&amp;gt;.</description></item></channel></rss>