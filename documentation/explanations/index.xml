<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Explanations on API Mocking and Testing | Microcks.io</title><link>https://microcks.io/documentation/explanations/</link><description>Recent content in Explanations on API Mocking and Testing | Microcks.io</description><generator>Hugo</generator><language>en-US</language><lastBuildDate>Thu, 23 Jan 2025 00:00:00 +0100</lastBuildDate><atom:link href="https://microcks.io/documentation/explanations/index.xml" rel="self" type="application/rss+xml"/><item><title>Deployment topologies</title><link>https://microcks.io/documentation/explanations/deployment-topologies/</link><pubDate>Tue, 10 Dec 2024 00:00:00 +0100</pubDate><guid>https://microcks.io/documentation/explanations/deployment-topologies/</guid><description>Introduction We often get the question from people who are adopting Microcks on the deployment toplogy: Where to deploy it and which personas to target? Microcks is modular and flexible, and it runs in many different ways, and having many options can make it unclear to novice users where to begin and how to get started.
In this article we share our experience on different tolopologies - or patterns - we&amp;rsquo;ve seen adopted depending on organization maturity and priorities.</description></item><item><title>Architecture &amp; deployment options</title><link>https://microcks.io/documentation/explanations/deployment-options/</link><pubDate>Tue, 15 Dec 2020 00:00:00 +0100</pubDate><guid>https://microcks.io/documentation/explanations/deployment-options/</guid><description>Introduction Microcks is a modular cloud-native application that can be deployed using many different installation methods. This documentation gives you details on internal components and exposes the different options for deploying them. It also discuss the pros and cons of those different options and the target usage they&amp;rsquo;re addressing.
Complete Logical Architecture In its most comprehensive form, Microcks architecture is made of components which are:
The Microcks main web application (also called webapp) that holds the UI resources as well as API endpoints, Its associated MongoDB database for holding your data such as the repository of APIs | Services and Tests, The Microcks Postman runtime (microcks-postman-runtime) that allows the execution of Postman Collection tests and calls back Microcks for storing results, An Apache Kafka broker that holds our private topic for changes and the public topics that will be used to publish mock messages by the microcks-async-minion.</description></item><item><title>Multi-artifacts support</title><link>https://microcks.io/documentation/explanations/multi-artifacts/</link><pubDate>Tue, 30 Apr 2024 00:00:00 +0200</pubDate><guid>https://microcks.io/documentation/explanations/multi-artifacts/</guid><description>Introduction Microcks can have multiple artifacts (one primary and many secondary) mapping to one API definition. The primary one will bring API or Service and operation metadata and examples. The secondary ones will only enrich existing operations with new non-conflicting requests/responses and event samples.
A typical illustration of this may be using an OpenAPI specification as a primary one and then bringing one (or many) additional Postman collections to provide examples or test constraints.</description></item><item><title>Dynamic mock content</title><link>https://microcks.io/documentation/explanations/dynamic-content/</link><pubDate>Tue, 11 Feb 2020 00:00:00 +0100</pubDate><guid>https://microcks.io/documentation/explanations/dynamic-content/</guid><description>Introduction Whilst we deeply think that &amp;ldquo;real-world&amp;rdquo; static values for request/response samples are crucial in order to fully understand the business usages and expectations of an API, we have to admit that it is more than often useful to introduce some kind of dynamically generated content for response.
Those use-case encompass:
random numbers that may be defined in a range, today&amp;rsquo;s date or today&amp;rsquo;s + an amount of time (for validity date for example), response part expressed from request part (body part, header, query param) Thus, Microcks has some templating features allowing to specify dynamic parts in response content.</description></item><item><title>Conformance testing</title><link>https://microcks.io/documentation/explanations/conformance-testing/</link><pubDate>Tue, 15 Dec 2020 00:00:00 +0100</pubDate><guid>https://microcks.io/documentation/explanations/conformance-testing/</guid><description>Introduction It is likely you experienced the painful situation of deploying to production only to find out that an API or Services you integrate with has broken its contract. How can we effectively ensure this does not happen?
As introduced in Main Concepts, Microcks can be used for Contract conformance testing of API or services being under development. You spend a lot of time describing request/response pairs and matching rules: it would be a shame not to use this sample as test cases once the development is on its way!</description></item><item><title>Service accounts</title><link>https://microcks.io/documentation/explanations/service-account/</link><pubDate>Sun, 01 Sep 2019 00:00:00 +0200</pubDate><guid>https://microcks.io/documentation/explanations/service-account/</guid><description>Introduction Microcks is using OpenId Connect and OAuth 2.0 bearer tokens to secure its frontend and API access. While this is very convenient for interactive users, it may be unpracticable for machine-to-machine authentication when you want to interact with Microcks from a robot, CI/CD pipeline or simple CLI tool. For that, we decided to implement the simple OAuth 2.0 Client Credentials Grant in addition of other grants. This authentication is implemented using Service Accounts clients defined into the Realm configuration in Keycloak.</description></item><item><title>Dispatcher &amp; dispatching rules</title><link>https://microcks.io/documentation/explanations/dispatching/</link><pubDate>Tue, 03 Mar 2020 00:00:00 +0100</pubDate><guid>https://microcks.io/documentation/explanations/dispatching/</guid><description>Introduction In order to provide smart mocks, Microcks is using Dispatcher and Dispatching Rules to find the most appropriate response to return when receiving a request.
The Dispatcher is defining a routing logic for mocks, that specifies the kind of elements of an incoming request will be examined to find a match. The Dispatcher Rules refines those elements as well as the matching rule to find the correct response.
By default, Microcks looks at the variable parts between the different examples of the same operation when importing a new Service or API and infers those two elements.</description></item><item><title>Monitoring &amp; Observability</title><link>https://microcks.io/documentation/explanations/monitoring/</link><pubDate>Fri, 09 Sep 2022 00:00:00 +0200</pubDate><guid>https://microcks.io/documentation/explanations/monitoring/</guid><description>Introduction As a cloud-native application, we take great care of providing observability on what&amp;rsquo;s going on within a Microcks instance. We dissociate two kinds of metrics: the Functional metrics are related to all the domain objects you may find in Microcks and the Technical metrics that are related to resource consumption and performance.
Functional metrics Microcks provides functional metrics directly from within its own REST API. This API will give you visibility on how you use the platform to invoke mocks, execute tests and enhance or degrade quality metrics.</description></item></channel></rss>