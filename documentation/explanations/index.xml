<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Explanations on API Mocking and Testing | Microcks.io</title><link>https://microcks.io/documentation/explanations/</link><description>Recent content in Explanations on API Mocking and Testing | Microcks.io</description><generator>Hugo</generator><language>en-US</language><lastBuildDate>Mon, 22 Sep 2025 00:00:00 +0200</lastBuildDate><atom:link href="https://microcks.io/documentation/explanations/index.xml" rel="self" type="application/rss+xml"/><item><title>Deployment topologies</title><link>https://microcks.io/documentation/explanations/deployment-topologies/</link><pubDate>Tue, 10 Dec 2024 00:00:00 +0100</pubDate><guid>https://microcks.io/documentation/explanations/deployment-topologies/</guid><description>&lt;h2 id="introduction"&gt;Introduction&lt;/h2&gt;
&lt;p&gt;We often get the question from people who are adopting Microcks on the deployment topology: &lt;strong&gt;Where to deploy it and which personas to target?&lt;/strong&gt; Microcks is modular and flexible, and it runs in many different ways. Having many options can make it unclear to novice users where to begin and how to get started.&lt;/p&gt;</description></item><item><title>Architecture &amp; deployment options</title><link>https://microcks.io/documentation/explanations/deployment-options/</link><pubDate>Tue, 15 Dec 2020 00:00:00 +0100</pubDate><guid>https://microcks.io/documentation/explanations/deployment-options/</guid><description>&lt;h2 id="introduction"&gt;Introduction&lt;/h2&gt;
&lt;p&gt;Microcks is a modular cloud-native application that can be deployed using many different &lt;a href="https://microcks.io/documentation/guides/installation"



 


&gt;installation methods&lt;/a&gt;. This documentation details internal components and exposes the different options for deploying them. It also discusses the pros and cons of those different options and the target usage they&amp;rsquo;re addressing.&lt;/p&gt;</description></item><item><title>Multi-artifacts support</title><link>https://microcks.io/documentation/explanations/multi-artifacts/</link><pubDate>Tue, 30 Apr 2024 00:00:00 +0200</pubDate><guid>https://microcks.io/documentation/explanations/multi-artifacts/</guid><description>&lt;h2 id="introduction"&gt;Introduction&lt;/h2&gt;
&lt;p&gt;Microcks can have multiple artifacts (one &lt;code&gt;primary&lt;/code&gt; and many &lt;code&gt;secondary&lt;/code&gt;) mapping to one API definition. The &lt;code&gt;primary&lt;/code&gt; one will bring API or Service and operation metadata and examples. The &lt;code&gt;secondary&lt;/code&gt; ones will only enrich existing operations with new non-conflicting requests/responses and event samples.&lt;/p&gt;</description></item><item><title>Dynamic mock content</title><link>https://microcks.io/documentation/explanations/dynamic-content/</link><pubDate>Tue, 11 Feb 2020 00:00:00 +0100</pubDate><guid>https://microcks.io/documentation/explanations/dynamic-content/</guid><description>&lt;h2 id="introduction"&gt;Introduction&lt;/h2&gt;
&lt;p&gt;Whilst we deeply think that &amp;ldquo;real-world&amp;rdquo; static values for request/response samples are crucial to fully understanding the business usages and expectations of an API, we have to admit that it is more than often useful to introduce some kind of dynamically generated content for the response.&lt;/p&gt;</description></item><item><title>MCP endpoints support</title><link>https://microcks.io/documentation/explanations/mcp-endpoints/</link><pubDate>Tue, 27 May 2025 00:00:00 +0200</pubDate><guid>https://microcks.io/documentation/explanations/mcp-endpoints/</guid><description>&lt;h2 id="introduction"&gt;Introduction&lt;/h2&gt;
&lt;p&gt;You know that API and AI are closely related and that LLMs and AI agents will be among the top consumers of your APIs tomorrow and even today. It becomes crucial to be able to check how AI Agents will reuse your API as tools!&lt;/p&gt;</description></item><item><title>Conformance testing</title><link>https://microcks.io/documentation/explanations/conformance-testing/</link><pubDate>Tue, 15 Dec 2020 00:00:00 +0100</pubDate><guid>https://microcks.io/documentation/explanations/conformance-testing/</guid><description>&lt;h2 id="introduction"&gt;Introduction&lt;/h2&gt;
&lt;p&gt;You may have experienced the frustration of deploying to production, only to discover that an API or service you integrate with has broken its contract. How can we effectively ensure this does not happen?&lt;/p&gt;</description></item><item><title>Service accounts</title><link>https://microcks.io/documentation/explanations/service-account/</link><pubDate>Sun, 01 Sep 2019 00:00:00 +0200</pubDate><guid>https://microcks.io/documentation/explanations/service-account/</guid><description>&lt;h2 id="introduction"&gt;Introduction&lt;/h2&gt;
&lt;p&gt;Microcks is using &lt;a href="https://openid.net/connect/"




 target="_blank"
 


&gt;OpenId Connect&lt;/a&gt; and &lt;a href="https://oauth.net/2/bearer-tokens/"




 target="_blank"
 


&gt;OAuth 2.0 bearer tokens&lt;/a&gt; to secure its frontend and API access. While this is very convenient for interactive users, it may be impractical for machine-to-machine authentication when you want to interact with Microcks from a robot, CI/CD pipeline or simple CLI tool. For that, we decided to implement the simple &lt;a href="https://oauth.net/2/grant-types/client-credentials/"




 target="_blank"
 


&gt;OAuth 2.0 Client Credentials Grant&lt;/a&gt; in addition to other grants. This authentication is implemented using &lt;em&gt;Service Accounts&lt;/em&gt; clients defined in the Realm configuration in Keycloak.&lt;/p&gt;</description></item><item><title>Dispatcher &amp; dispatching rules</title><link>https://microcks.io/documentation/explanations/dispatching/</link><pubDate>Tue, 03 Mar 2020 00:00:00 +0100</pubDate><guid>https://microcks.io/documentation/explanations/dispatching/</guid><description>&lt;h2 id="introduction"&gt;Introduction&lt;/h2&gt;
&lt;p&gt;In order to provide smart mocks, Microcks is using &lt;code&gt;Dispatcher&lt;/code&gt; and &lt;code&gt;Dispatching Rules&lt;/code&gt; to find the most appropriate response to return when receiving a request.&lt;/p&gt;</description></item><item><title>Monitoring &amp; Observability</title><link>https://microcks.io/documentation/explanations/monitoring/</link><pubDate>Fri, 09 Sep 2022 00:00:00 +0200</pubDate><guid>https://microcks.io/documentation/explanations/monitoring/</guid><description>&lt;h2 id="introduction"&gt;Introduction&lt;/h2&gt;
&lt;p&gt;As a cloud-native application, we take great care of providing observability on what&amp;rsquo;s going on within a Microcks instance. We dissociate two kinds of metrics: the &lt;strong&gt;Functional metrics&lt;/strong&gt; related to all the domain objects you may find in Microcks and the &lt;strong&gt;Technical metrics&lt;/strong&gt; related to resource consumption and performance.&lt;/p&gt;</description></item></channel></rss>